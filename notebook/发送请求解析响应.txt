private ClientRequest request(long now, String node, MetadataRequest metadata) {
	// 三个参数依次为  String destination, RequestHeader header, Struct body
	RequestSend send = new RequestSend(node, nextRequestHeader(ApiKeys.METADATA), metadata.toStruct());
	return new ClientRequest(now, true, send, null, true);
}

ClientRequest clientRequest = new ClientRequest(now, true, send, null, true);

header = new RequestHeader(key.id, clientId, correlation++)

//body
struct.set(TOPICS_KEY_NAME, topics.toArray());


//序列化请求头跟请求体
public static ByteBuffer serialize(RequestHeader header, Struct body) {
	ByteBuffer buffer = ByteBuffer.allocate(header.sizeOf() + body.sizeOf());
	header.writeTo(buffer);
	body.writeTo(buffer);
	//todo 重置position = 0
	buffer.rewind();
	return buffer;
}

//delimit 划界,界定
private static ByteBuffer[] sizeDelimit(ByteBuffer[] buffers) {
	int size = 0;
	for (int i = 0; i < buffers.length; i++)
		size += buffers[i].remaining();
	ByteBuffer[] delimited = new ByteBuffer[buffers.length + 1];
	//分配四个字节 用于存数据大小
	delimited[0] = ByteBuffer.allocate(4);
	//todo 数据大小
	delimited[0].putInt(size);
	delimited[0].rewind();
	System.arraycopy(buffers, 0, delimited, 1, buffers.length);
	return delimited;
}

//针对响应主题元数据
"brokers" -> {Field@1485}
"cluster_id" -> {Field@1483}
"controller_id" -> {Field@1487}
"topic_metadata" -> {Field@1481}


public static final Schema METADATA_RESPONSE_V2 = new Schema(
// ArrayOf 数组
new Field("brokers", new ArrayOf(METADATA_BROKER_V1),"Host and port information for all brokers."),
new Field("cluster_id", NULLABLE_STRING,"The cluster id that this broker belongs to."),
new Field("controller_id", INT32,"The broker id of the controller broker."),
new Field("topic_metadata", new ArrayOf(TOPIC_METADATA_V1)));

String name, Type type, String doc

new Schema(
new Field("node_id", INT32, "The broker id."),
new Field("host", STRING, "The hostname of the broker."),
new Field("port", INT32,"The port on which the broker accepts requests."),
new Field("rack", NULLABLE_STRING, "The rack of the broker."));